// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © polypokrbinc

//@version=5
strategy("Advanced DCA Strategy with Veles Integration", 
         overlay=true, 
         pyramiding=20, 
         default_qty_type=strategy.percent_of_equity,
         default_qty_value=5,
         initial_capital=1000,
         commission_type=strategy.commission.percent,
         commission_value=0.1,
         calc_on_order_fills=true,
         process_orders_on_close=true,
         max_bars_back=500)

// ======== HELPER FUNCTIONS ========
// Non-repainting MTF function
f_security(_symbol, _res, _src, _repaint) =>
    request.security(_symbol, _res, _src[_repaint ? 0 : barstate.isrealtime ? 1 : 0])[_repaint ? 0 : barstate.isrealtime ? 0 : 1]

// ======== DCA GRID SETTINGS ========
group_grid = "======== GRID SETTINGS ========"
use_grid = input.bool(true, "Activate DCA Grid ?", group=group_grid)
grid_direction = input.string("Short", "Long or Short Grid ?", options=["Long", "Short"], group=group_grid)
deposit_size = input.float(100, "Deposit for Bot (for the entire grid) ($)", minval=1, step=0.1, group=group_grid)
leverage = input.int(10, "Leverage (1x-20x)", minval=1, maxval=20, group=group_grid)
grid_size_percent = input.float(15, "Grid Size (%)", minval=0.1, step=0.1, group=group_grid)
num_orders = input.int(6, "Number of orders in the grid (3-15)", minval=3, maxval=15, group=group_grid)
martingale = input.float(1.25, "Orders Value Martingale (1.0-1.8)", minval=1.0, maxval=1.8, step=0.01, group=group_grid)
log_steps = input.float(1.1, "Logarithmic Orders Steps (0.8-1.4)", minval=0.8, maxval=1.4, step=0.01, group=group_grid)
close_on_drawdown = input.bool(true, "Close All Orders on Big Drawdown ?", group=group_grid)
drawdown_limit = input.float(-95, "Drawdown to close (-$)", maxval=0, step=0.1, group=group_grid)
change_tp_many = input.bool(false, "Change Take Profit if Many Orders ?", group=group_grid)
new_tp_percent = input.float(0.4, "Set Take Profit to X%", minval=0.1, step=0.1, group=group_grid)
orders_threshold = input.int(5, "If Orders more than N", minval=1, group=group_grid)
alert_first_only = input.bool(false, "Send Alert only for First Order", group=group_grid)

// ======== VISUALIZATION SETTINGS ========
group_viz = "======== VISUALIZATION ========"
show_tp_sl = input.bool(true, "Show TP/SL on Chart", group=group_viz)
show_signals = input.bool(true, "Show Signals on Chart", group=group_viz)

// ======== BACKTEST PERIOD ========
group_period = "======== BACKTEST PERIOD ========"
use_date_filter = input.bool(false, "Use Date Filter", group=group_period)
start_date = input.time(timestamp("2023-01-01"), "Start Date", group=group_period)
end_date = input.time(timestamp("2024-12-31"), "End Date", group=group_period)

// ======== TRADING DAYS FILTER ========
group_days = "======== TRADING DAYS ========"
trade_monday = input.bool(true, "Trade on Monday", group=group_days)
trade_tuesday = input.bool(true, "Trade on Tuesday", group=group_days)
trade_wednesday = input.bool(true, "Trade on Wednesday", group=group_days)
trade_thursday = input.bool(true, "Trade on Thursday", group=group_days)
trade_friday = input.bool(true, "Trade on Friday", group=group_days)
trade_saturday = input.bool(true, "Trade on Saturday", group=group_days)
trade_sunday = input.bool(true, "Trade on Sunday", group=group_days)

// ======== STATIC SL/TP SETTINGS ========
group_sltp = "======== STATIC SL/TP ========"
use_long = input.bool(true, "Use Long ?", group=group_sltp)
use_short = input.bool(true, "Use Short ?", group=group_sltp)
sl_equals_tp = input.bool(false, "SL = TP ?", group=group_sltp)
take_profit_percent = input.float(5, "Take Profit (%)", minval=0.1, step=0.1, group=group_sltp)
stop_loss_percent = input.float(2.2, "Stop Loss (%)", minval=0.1, step=0.1, group=group_sltp)

// ======== REVERSE ORDERS ========
group_reverse = "======== REVERSE ORDERS ========"
reverse_on_sl = input.bool(false, "Reverse Order on SL Hit", group=group_reverse)
reverse_on_be = input.bool(false, "Reverse Order on BE Hit", group=group_reverse)

// ======== CLOSE ONLY IN PROFIT ========
group_profit_only = "======== PROFIT ONLY CLOSE ========"
close_profit_only = input.bool(false, "Close Only in Profit", group=group_profit_only)

// ======== BREAKEVEN SETTINGS ========
group_be = "======== BREAKEVEN ========"
use_breakeven = input.bool(false, "Use Breakeven", group=group_be)
be_trigger_percent = input.float(2.0, "BE Trigger (%)", minval=0.1, step=0.1, group=group_be)
be_offset_percent = input.float(0.2, "BE Offset (%)", minval=0, step=0.1, group=group_be)

// ======== MULTI TAKE PROFITS ========
group_mtp = "======== MULTI TAKE PROFITS ========"
use_multi_tp = input.bool(false, "Use Multi TP", group=group_mtp)
tp1_percent = input.float(1, "TP1 Level (%)", minval=0.1, step=0.1, group=group_mtp)
tp1_qty = input.float(25, "TP1 Quantity (%)", minval=1, maxval=100, step=1, group=group_mtp)
tp2_percent = input.float(2, "TP2 Level (%)", minval=0.1, step=0.1, group=group_mtp)
tp2_qty = input.float(25, "TP2 Quantity (%)", minval=1, maxval=100, step=1, group=group_mtp)
tp3_percent = input.float(3, "TP3 Level (%)", minval=0.1, step=0.1, group=group_mtp)
tp3_qty = input.float(25, "TP3 Quantity (%)", minval=1, maxval=100, step=1, group=group_mtp)
tp4_percent = input.float(4, "TP4 Level (%)", minval=0.1, step=0.1, group=group_mtp)
tp4_qty = input.float(25, "TP4 Quantity (%)", minval=1, maxval=100, step=1, group=group_mtp)

// ======== PYRAMIDING SETTINGS ========
group_pyramid = "======== PYRAMIDING ========"
min_price_move = input.float(0.5, "Min Price Move for Pyramiding (%)", minval=0.1, step=0.1, group=group_pyramid)

// ======== TRAILING STOP ========
group_trail = "======== TRAILING STOP ========"
use_trailing = input.bool(false, "Use Trailing Stop", group=group_trail)
trail_activate_percent = input.float(2, "Trailing Activation (%)", minval=0.1, step=0.1, group=group_trail)
trail_distance_percent = input.float(1, "Trailing Distance (%)", minval=0.1, step=0.1, group=group_trail)

// ======== ORDER INDENT ========
group_indent = "======== ORDER INDENT ========"
use_indent = input.bool(false, "Use Order Indent", group=group_indent)
indent_percent = input.float(0.1, "Indent (%)", step=0.01, group=group_indent)
cancel_after_bars = input.int(5, "Cancel Signal After N Bars", minval=1, group=group_indent)

// ======== ATR STOP LOSS ========
group_atr_sl = "======== ATR STOP LOSS ========"
use_atr_sl = input.bool(false, "Use ATR Stop Loss", group=group_atr_sl)
atr_sl_length = input.int(14, "ATR Length", minval=1, group=group_atr_sl)
atr_sl_mult = input.float(2.0, "ATR Multiplier", minval=0.1, step=0.1, group=group_atr_sl)

// ======== ATR TAKE PROFIT ========
group_atr_tp = "======== ATR TAKE PROFIT ========"
use_atr_tp = input.bool(false, "Use ATR Take Profit", group=group_atr_tp)
atr_tp_length = input.int(14, "ATR Length", minval=1, group=group_atr_tp)
atr_tp_mult = input.float(3.0, "ATR Multiplier", minval=0.1, step=0.1, group=group_atr_tp)

// ======== VOLATILITY FILTER ========
group_vol_filter = "======== VOLATILITY FILTER ========"
use_vol_filter = input.bool(false, "Use Volatility Filter", group=group_vol_filter)
vol_length = input.int(20, "Volatility Length", minval=1, group=group_vol_filter)
vol_min = input.float(0.5, "Min Volatility (%)", minval=0, step=0.1, group=group_vol_filter)
vol_max = input.float(5.0, "Max Volatility (%)", minval=0, step=0.1, group=group_vol_filter)

// ======== VOLUME FILTER ========
group_volume_filter = "======== VOLUME FILTER ========"
use_volume_filter = input.bool(false, "Use Volume Filter", group=group_volume_filter)
volume_length = input.int(20, "Volume MA Length", minval=1, group=group_volume_filter)
volume_mult_min = input.float(0.5, "Min Volume Multiplier", minval=0.1, step=0.1, group=group_volume_filter)
volume_mult_max = input.float(3.0, "Max Volume Multiplier", minval=0.1, step=0.1, group=group_volume_filter)

// ======== HIGH/LOW PRICE FILTER ========
group_hl_filter = "======== HIGH/LOW FILTER ========"
use_hl_filter = input.bool(false, "Use High/Low Filter", group=group_hl_filter)
hl_period = input.int(20, "High/Low Period", minval=1, group=group_hl_filter)
hl_min_change = input.float(2.0, "Min Price Change (%)", minval=0, step=0.1, group=group_hl_filter)

// ======== ATR GROWTH FILTER ========
group_atr_growth = "======== ATR GROWTH FILTER ========"
use_atr_growth = input.bool(false, "Use ATR Growth Filter", group=group_atr_growth)
atr_growth_length = input.int(20, "ATR Comparison Length", minval=1, group=group_atr_growth)
atr_growth_min = input.float(10, "Min ATR Growth (%)", minval=0, step=1, group=group_atr_growth)

// ======== BLOCK IF WORSE THAN ========
group_worse = "======== BLOCK IF WORSE THAN ========"
use_worse_filter = input.bool(false, "Block if Worse Than", group=group_worse)
worse_percent = input.float(0.5, "Worse Than (%)", minval=0, step=0.1, group=group_worse)

// ======== BTC SOURCE OPTION ========
group_btc = "======== BTC SOURCE ========"
use_btc_source = input.bool(false, "Use BTCUSDT as Source for Indicators", group=group_btc)

// ======== SUPERTREND FILTERS ========
group_supertrend = "======== SUPERTREND FILTERS ========"
// SuperTrend 1
use_supertrend1 = input.bool(false, "Use SuperTrend 1", group=group_supertrend)
supertrend1_length = input.int(10, "ST1 Length", minval=1, group=group_supertrend)
supertrend1_mult = input.float(3.0, "ST1 Multiplier", minval=0.1, step=0.1, group=group_supertrend)
supertrend1_tf = input.timeframe("", "ST1 Timeframe", group=group_supertrend)

// SuperTrend 2
use_supertrend2 = input.bool(false, "Use SuperTrend 2", group=group_supertrend)
supertrend2_length = input.int(14, "ST2 Length", minval=1, group=group_supertrend)
supertrend2_mult = input.float(2.0, "ST2 Multiplier", minval=0.1, step=0.1, group=group_supertrend)
supertrend2_tf = input.timeframe("", "ST2 Timeframe", group=group_supertrend)

// SuperTrend 3
use_supertrend3 = input.bool(false, "Use SuperTrend 3", group=group_supertrend)
supertrend3_length = input.int(20, "ST3 Length", minval=1, group=group_supertrend)
supertrend3_mult = input.float(1.5, "ST3 Multiplier", minval=0.1, step=0.1, group=group_supertrend)
supertrend3_tf = input.timeframe("", "ST3 Timeframe", group=group_supertrend)

// SuperTrend Trend Change Signal
use_st_trend_change = input.bool(false, "Use SuperTrend Trend Change Signal", group=group_supertrend)

// ======== CONSOLIDATION ZONES ========
group_consolidation = "======== CONSOLIDATION ZONES ========"
use_consolidation = input.bool(false, "Use Consolidation Zones", group=group_consolidation)
consol_length = input.int(20, "Consolidation Length", minval=5, group=group_consolidation)
consol_range = input.float(2.0, "Max Range (%)", minval=0.1, step=0.1, group=group_consolidation)

// ======== TWO MOVING AVERAGES ========
group_ma = "======== TWO MAs ========"
use_ma = input.bool(false, "Use Two MAs", group=group_ma)
ma1_type = input.string("SMA", "MA1 Type", options=["SMA", "EMA", "WMA", "HMA", "RMA", "VWMA"], group=group_ma)
ma1_length = input.int(10, "MA1 Length", minval=1, group=group_ma)
ma2_type = input.string("SMA", "MA2 Type", options=["SMA", "EMA", "WMA", "HMA", "RMA", "VWMA"], group=group_ma)
ma2_length = input.int(20, "MA2 Length", minval=1, group=group_ma)
ma_mode = input.string("Cross", "MA Mode", options=["Cross", "Direction", "Trend"], group=group_ma)

// ======== KELTNER/BOLLINGER CHANNELS ========
group_channel = "======== KELTNER/BOLLINGER CHANNELS ========"
use_channel = input.bool(true, "Use Channel ?", group=group_channel)
channel_type = input.string("Bollinger", "Channel Type", options=["Keltner", "Bollinger"], group=group_channel)
channel_mode = input.string("Rebound", "BB/KC Channel Breakout or Rebound from Bands", options=["Breakout", "Rebound"], group=group_channel)
channel_entry = input.string("Wick outside", "Entry Conditions", options=["Wick outside", "Close outside, return and close inside"], group=group_channel)
keltner_length = input.int(14, "Keltner Length", minval=1, group=group_channel)
keltner_mult = input.float(1.5, "Keltner Multiplier", minval=0.1, step=0.1, group=group_channel)
bb_length = input.int(200, "BB Length", minval=1, group=group_channel)
bb_dev = input.float(2.1, "BB Deviation", minval=0.1, step=0.1, group=group_channel)
channel_tf = input.timeframe("", "Channel Timeframe", group=group_channel)

// ======== RSI INDICATORS ========
group_rsi = "======== RSI - MULTI TIMEFRAME [1] ========"
// RSI 1
use_rsi1 = input.bool(true, "Use RSI 1", group=group_rsi)
rsi1_length = input.int(14, "RSI 1 Length", minval=1, group=group_rsi)
rsi1_tf = input.timeframe("", "RSI 1 Timeframe", group=group_rsi)
use_rsi1_long = input.bool(true, "Use RSI LONG Range", group=group_rsi)
rsi1_long_above = input.float(20, "(LONG) RSI is More", minval=0, maxval=100, group=group_rsi)
rsi1_long_below = input.float(50, "& RSI is Less", minval=0, maxval=100, group=group_rsi)
use_rsi1_short = input.bool(true, "Use RSI SHORT Range", group=group_rsi)
rsi1_short_below = input.float(80, "(SHORT) RSI is Less", minval=0, maxval=100, group=group_rsi)
rsi1_short_above = input.float(50, "& RSI is More", minval=0, maxval=100, group=group_rsi)
use_rsi1_cross = input.bool(false, "Use RSI Cross Signals", group=group_rsi)

// RSI 2
group_rsi2 = "======== RSI - MULTI TIMEFRAME [2] ========"
use_rsi2 = input.bool(false, "Use RSI 2", group=group_rsi2)
rsi2_length = input.int(21, "RSI 2 Length", minval=1, group=group_rsi2)
rsi2_tf = input.timeframe("", "RSI 2 Timeframe", group=group_rsi2)
use_rsi2_long = input.bool(true, "Use RSI LONG Range", group=group_rsi2)
rsi2_long_above = input.float(30, "(LONG) RSI is More", minval=0, maxval=100, group=group_rsi2)
rsi2_long_below = input.float(70, "& RSI is Less", minval=0, maxval=100, group=group_rsi2)
use_rsi2_short = input.bool(true, "Use RSI SHORT Range", group=group_rsi2)
rsi2_short_below = input.float(70, "(SHORT) RSI is Less", minval=0, maxval=100, group=group_rsi2)
rsi2_short_above = input.float(30, "& RSI is More", minval=0, maxval=100, group=group_rsi2)

// RSI 3
group_rsi3 = "======== RSI - MULTI TIMEFRAME [3] ========"
use_rsi3 = input.bool(false, "Use RSI 3", group=group_rsi3)
rsi3_length = input.int(7, "RSI 3 Length", minval=1, group=group_rsi3)
rsi3_tf = input.timeframe("", "RSI 3 Timeframe", group=group_rsi3)
use_rsi3_long = input.bool(true, "Use RSI LONG Range", group=group_rsi3)
rsi3_long_above = input.float(25, "(LONG) RSI is More", minval=0, maxval=100, group=group_rsi3)
rsi3_long_below = input.float(45, "& RSI is Less", minval=0, maxval=100, group=group_rsi3)
use_rsi3_short = input.bool(true, "Use RSI SHORT Range", group=group_rsi3)
rsi3_short_below = input.float(75, "(SHORT) RSI is Less", minval=0, maxval=100, group=group_rsi3)
rsi3_short_above = input.float(55, "& RSI is More", minval=0, maxval=100, group=group_rsi3)

// ======== RVI INDICATOR ========
group_rvi = "======== RVI ========"
use_rvi = input.bool(false, "Use RVI", group=group_rvi)
rvi_length = input.int(14, "RVI Length", minval=1, group=group_rvi)
rvi_long_above = input.float(-0.2, "(LONG) RVI is More", group=group_rvi)
rvi_long_below = input.float(0.2, "& RVI is Less", group=group_rvi)
rvi_short_below = input.float(0.2, "(SHORT) RVI is Less", group=group_rvi)
rvi_short_above = input.float(-0.2, "& RVI is More", group=group_rvi)

// ======== MFI INDICATOR ========
group_mfi = "======== MFI ========"
use_mfi = input.bool(false, "Use MFI", group=group_mfi)
mfi_length = input.int(14, "MFI Length", minval=1, group=group_mfi)
mfi_long_above = input.float(20, "(LONG) MFI is More", minval=0, maxval=100, group=group_mfi)
mfi_long_below = input.float(50, "& MFI is Less", minval=0, maxval=100, group=group_mfi)
mfi_short_below = input.float(80, "(SHORT) MFI is Less", minval=0, maxval=100, group=group_mfi)
mfi_short_above = input.float(50, "& MFI is More", minval=0, maxval=100, group=group_mfi)

// ======== CCI INDICATOR ========
group_cci = "======== CCI ========"
use_cci = input.bool(false, "Use CCI", group=group_cci)
cci_length = input.int(20, "CCI Length", minval=1, group=group_cci)
cci_long_above = input.float(-100, "(LONG) CCI is More", group=group_cci)
cci_long_below = input.float(100, "& CCI is Less", group=group_cci)
cci_short_below = input.float(100, "(SHORT) CCI is Less", group=group_cci)
cci_short_above = input.float(-100, "& CCI is More", group=group_cci)

// ======== STOCHASTIC OSCILLATOR ========
group_stoch = "======== STOCHASTIC ========"
use_stoch = input.bool(false, "Use Stochastic", group=group_stoch)
stoch_k_length = input.int(14, "Stoch K Length", minval=1, group=group_stoch)
stoch_d_length = input.int(3, "Stoch D Length", minval=1, group=group_stoch)
stoch_smooth = input.int(3, "Stoch Smooth", minval=1, group=group_stoch)
stoch_long_above = input.float(20, "(LONG) Stoch is More", minval=0, maxval=100, group=group_stoch)
stoch_long_below = input.float(50, "& Stoch is Less", minval=0, maxval=100, group=group_stoch)
stoch_short_below = input.float(80, "(SHORT) Stoch is Less", minval=0, maxval=100, group=group_stoch)
stoch_short_above = input.float(50, "& Stoch is More", minval=0, maxval=100, group=group_stoch)
use_stoch_cross = input.bool(false, "Use Stoch Cross Signals", group=group_stoch)

// ======== MOMENTUM INDICATOR ========
group_mom = "======== MOMENTUM ========"
use_mom = input.bool(false, "Use Momentum", group=group_mom)
mom_length = input.int(10, "Momentum Length", minval=1, group=group_mom)
mom_long_above = input.float(-2, "(LONG) Mom is More", group=group_mom)
mom_long_below = input.float(2, "& Mom is Less", group=group_mom)
mom_short_below = input.float(2, "(SHORT) Mom is Less", group=group_mom)
mom_short_above = input.float(-2, "& Mom is More", group=group_mom)

// ======== DYNAMIC RSI ========
group_drsi = "======== DYNAMIC RSI ========"
use_drsi = input.bool(false, "Use Dynamic RSI", group=group_drsi)
drsi_length = input.int(14, "Dynamic RSI Length", minval=1, group=group_drsi)
drsi_long_above = input.float(30, "(LONG) DRSI is More", minval=0, maxval=100, group=group_drsi)
drsi_long_below = input.float(70, "& DRSI is Less", minval=0, maxval=100, group=group_drsi)
drsi_short_below = input.float(70, "(SHORT) DRSI is Less", minval=0, maxval=100, group=group_drsi)
drsi_short_above = input.float(30, "& DRSI is More", minval=0, maxval=100, group=group_drsi)

// ======== DYNAMIC MFI ========
group_dmfi = "======== DYNAMIC MFI ========"
use_dmfi = input.bool(false, "Use Dynamic MFI", group=group_dmfi)
dmfi_length = input.int(14, "Dynamic MFI Length", minval=1, group=group_dmfi)
dmfi_long_above = input.float(30, "(LONG) DMFI is More", minval=0, maxval=100, group=group_dmfi)
dmfi_long_below = input.float(70, "& DMFI is Less", minval=0, maxval=100, group=group_dmfi)
dmfi_short_below = input.float(70, "(SHORT) DMFI is Less", minval=0, maxval=100, group=group_dmfi)
dmfi_short_above = input.float(30, "& DMFI is More", minval=0, maxval=100, group=group_dmfi)

// ======== SMI ERGODIC OSCILLATOR ========
group_smi = "======== SMI ERGODIC ========"
use_smi = input.bool(false, "Use SMI Ergodic", group=group_smi)
smi_short_length = input.int(5, "SMI Short Length", minval=1, group=group_smi)
smi_long_length = input.int(20, "SMI Long Length", minval=1, group=group_smi)
smi_signal_length = input.int(5, "SMI Signal Length", minval=1, group=group_smi)
smi_long_above = input.float(-10, "(LONG) SMI is More", group=group_smi)
smi_long_below = input.float(10, "& SMI is Less", group=group_smi)
smi_short_below = input.float(10, "(SHORT) SMI is Less", group=group_smi)
smi_short_above = input.float(-10, "& SMI is More", group=group_smi)

// ======== DMI INDICATOR ========
group_dmi = "======== DMI ========"
use_dmi = input.bool(false, "Use DMI", group=group_dmi)
dmi_length = input.int(14, "DMI Length", minval=1, group=group_dmi)
dmi_adx_smooth = input.int(14, "ADX Smoothing", minval=1, group=group_dmi)
use_dmi_filter = input.string("ADX", "DMI Filter Type", options=["ADX", "DI+", "DI-"], group=group_dmi)
dmi_threshold = input.float(25, "DMI Threshold", minval=0, group=group_dmi)

// ======== CHAIKIN MONEY FLOW ========
group_cmf = "======== CHAIKIN MONEY FLOW ========"
use_cmf = input.bool(false, "Use CMF", group=group_cmf)
cmf_length = input.int(20, "CMF Length", minval=1, group=group_cmf)
cmf_long_above = input.float(-0.1, "(LONG) CMF is More", group=group_cmf)
cmf_long_below = input.float(0.1, "& CMF is Less", group=group_cmf)
cmf_short_below = input.float(0.1, "(SHORT) CMF is Less", group=group_cmf)
cmf_short_above = input.float(-0.1, "& CMF is More", group=group_cmf)
use_cmf_cross = input.bool(false, "Use CMF Zero Cross", group=group_cmf)

// ======== BALANCE OF POWER ========
group_bop = "======== BALANCE OF POWER ========"
use_bop = input.bool(false, "Use BOP", group=group_bop)
bop_length = input.int(14, "BOP Length", minval=1, group=group_bop)
bop_long_above = input.float(-0.1, "(LONG) BOP is More", group=group_bop)
bop_long_below = input.float(0.1, "& BOP is Less", group=group_bop)
bop_short_below = input.float(0.1, "(SHORT) BOP is Less", group=group_bop)
bop_short_above = input.float(-0.1, "& BOP is More", group=group_bop)
use_bop_cross = input.bool(false, "Use BOP Zero Cross", group=group_bop)
// ======== MACD SIGNALS ========
group_macd = "======== MACD SIGNALS ========"
use_macd = input.bool(false, "Use MACD", group=group_macd)
macd_fast_length = input.int(12, "MACD Fast Length", minval=1, group=group_macd)
macd_slow_length = input.int(26, "MACD Slow Length", minval=1, group=group_macd)
macd_signal_length = input.int(9, "MACD Signal Length", minval=1, group=group_macd)
macd_signal_type = input.string("Signal Cross", "MACD Signal Type", options=["Zero Cross", "Signal Cross"], group=group_macd)

// ======== LEVELS BREAK ========
group_levels = "======== LEVELS BREAK ========"
use_levels_break = input.bool(false, "Use Levels Break", group=group_levels)
levels_lookback = input.int(50, "Lookback Period", minval=10, group=group_levels)
levels_touches = input.int(3, "Required Touches", minval=2, maxval=5, group=group_levels)
levels_tolerance = input.float(0.1, "Level Tolerance (%)", minval=0.01, step=0.01, group=group_levels)
levels_close_profit = input.float(2.0, "Close at Opposite Level Profit (%)", minval=0.1, step=0.1, group=group_levels)

// ======== QQE SIGNALS ========
group_qqe = "======== QQE SIGNALS ========"
use_qqe = input.bool(false, "Use QQE", group=group_qqe)
qqe_rsi_length = input.int(14, "QQE RSI Length", minval=1, group=group_qqe)
qqe_sf = input.int(5, "QQE SF", minval=1, group=group_qqe)
qqe_wilders_length = input.float(4.236, "QQE Wilders Length", minval=0.1, step=0.1, group=group_qqe)

// ======== DIVERGENCES ========
group_div = "======== DIVERGENCES ========"
use_divergence = input.bool(false, "Use Divergences", group=group_div)
div_lookback = input.int(50, "Divergence Lookback", minval=10, group=group_div)
div_indicator = input.string("RSI", "Divergence Indicator", options=["RSI", "MACD", "Stochastic", "MFI", "CCI", "Momentum"], group=group_div)
div_type = input.string("Regular", "Divergence Type", options=["Regular", "Hidden", "Both"], group=group_div)

// ======== CANDLESTICK PATTERNS ========
group_patterns = "======== CANDLESTICK PATTERNS ========"
use_patterns = input.bool(false, "Use Candlestick Patterns", group=group_patterns)
patterns_tf = input.timeframe("", "Patterns Timeframe", group=group_patterns)
use_hammer = input.bool(true, "Hammer/Hanging Man", group=group_patterns)
use_engulfing = input.bool(true, "Engulfing", group=group_patterns)
use_doji = input.bool(true, "Doji", group=group_patterns)
use_morning_evening_star = input.bool(true, "Morning/Evening Star", group=group_patterns)
use_three_soldiers_crows = input.bool(true, "Three Soldiers/Crows", group=group_patterns)

// ======== LINEAR REGRESSION CHANNEL ========
group_lrc = "======== LINEAR REGRESSION CHANNEL ========"
use_lrc = input.bool(false, "Use LRC", group=group_lrc)
lrc_length = input.int(50, "LRC Length", minval=10, group=group_lrc)
lrc_deviation = input.float(2.0, "LRC Deviation", minval=0.1, step=0.1, group=group_lrc)

// ======== EXTERNAL INDICATORS ========
group_ext = "======== EXTERNAL INDICATORS ========"
use_external = input.bool(false, "Use External Indicator", group=group_ext)
ext_long_condition = input.source(close, "External Long Signal", group=group_ext)
ext_short_condition = input.source(close, "External Short Signal", group=group_ext)
ext_long_threshold = input.float(1, "Long Threshold", group=group_ext)
ext_short_threshold = input.float(-1, "Short Threshold", group=group_ext)

// ======== CLOSE SIGNALS - BREAKEVEN ========
group_close_be = "======== CLOSE SIGNALS - BREAKEVEN ========"
close_on_be = input.bool(false, "Close on Breakeven", group=group_close_be)

// ======== CLOSE SIGNALS - TRAILING STOP ========
group_close_trail = "======== CLOSE SIGNALS - TRAILING ========"
close_on_trail = input.bool(false, "Close on Trailing Stop", group=group_close_trail)

// ======== CLOSE SIGNALS - STATIC TP/SL ========
group_close_static = "======== CLOSE SIGNALS - STATIC ========"
close_on_tp = input.bool(true, "Close on Take Profit", group=group_close_static)
close_on_sl = input.bool(true, "Close on Stop Loss", group=group_close_static)

// ======== CLOSE SIGNALS - ATR TP/SL ========
group_close_atr = "======== CLOSE SIGNALS - ATR ========"
close_on_atr_tp = input.bool(false, "Close on ATR TP", group=group_close_atr)
close_on_atr_sl = input.bool(false, "Close on ATR SL", group=group_close_atr)

// ======== CLOSE SIGNALS - PARABOLIC SAR ========
group_close_sar = "======== CLOSE SIGNALS - SAR ========"
use_sar_close = input.bool(false, "Use SAR Close", group=group_close_sar)
sar_start = input.float(0.02, "SAR Start", minval=0.001, step=0.001, group=group_close_sar)
sar_increment = input.float(0.02, "SAR Increment", minval=0.001, step=0.001, group=group_close_sar)
sar_max = input.float(0.2, "SAR Max", minval=0.01, step=0.01, group=group_close_sar)

// ======== CLOSE SIGNALS - CHANNELS ========
group_close_channel = "======== CLOSE SIGNALS - CHANNELS ========"
use_channel_close = input.bool(false, "Use Channel Close", group=group_close_channel)
close_channel_type = input.string("Bollinger", "Close Channel Type", options=["Keltner", "Bollinger"], group=group_close_channel)

// ======== CLOSE SIGNALS - RSI ========
group_close_rsi = "======== CLOSE SIGNALS - RSI ========"
use_rsi_close = input.bool(false, "Use RSI Close", group=group_close_rsi)
rsi_close_type = input.string("Level", "RSI Close Type", options=["Level", "Cross"], group=group_close_rsi)
rsi_close_long_level = input.float(70, "RSI Close Long Level", minval=0, maxval=100, group=group_close_rsi)
rsi_close_short_level = input.float(30, "RSI Close Short Level", minval=0, maxval=100, group=group_close_rsi)

// ======== CLOSE SIGNALS - STOCHASTIC ========
group_close_stoch = "======== CLOSE SIGNALS - STOCH ========"
use_stoch_close = input.bool(false, "Use Stoch Close", group=group_close_stoch)
stoch_close_type = input.string("Level", "Stoch Close Type", options=["Level", "Cross"], group=group_close_stoch)
stoch_close_long_level = input.float(80, "Stoch Close Long Level", minval=0, maxval=100, group=group_close_stoch)
stoch_close_short_level = input.float(20, "Stoch Close Short Level", minval=0, maxval=100, group=group_close_stoch)

// ======== CLOSE SIGNALS - MA CROSS ========
group_close_ma = "======== CLOSE SIGNALS - MA CROSS ========"
use_ma_close = input.bool(false, "Use MA Cross Close", group=group_close_ma)

// ======== WEBHOOK SETTINGS ========
group_webhook = "======== WEBHOOK SETTINGS ========"
webhook_message_long = input.string("LONG", "Webhook Long Message", group=group_webhook)
webhook_message_short = input.string("SHORT", "Webhook Short Message", group=group_webhook)
webhook_message_close = input.string("CLOSE", "Webhook Close Message", group=group_webhook)

// ======== CALCULATIONS START HERE ========

// Date Filter
inDateRange = not use_date_filter or (time >= start_date and time <= end_date)

// Day of week filter
dayOfWeek = dayofweek(time)
tradingDay = (dayOfWeek == dayofweek.monday and trade_monday) or
             (dayOfWeek == dayofweek.tuesday and trade_tuesday) or
             (dayOfWeek == dayofweek.wednesday and trade_wednesday) or
             (dayOfWeek == dayofweek.thursday and trade_thursday) or
             (dayOfWeek == dayofweek.friday and trade_friday) or
             (dayOfWeek == dayofweek.saturday and trade_saturday) or
             (dayOfWeek == dayofweek.sunday and trade_sunday)

// ATR Calculations
atr_sl = ta.atr(atr_sl_length) * atr_sl_mult
atr_tp = ta.atr(atr_tp_length) * atr_tp_mult

// Volatility Filter
volatility = (high - low) / close * 100
vol_condition = not use_vol_filter or (volatility >= vol_min and volatility <= vol_max)

// Volume Filter  
vol_ma = ta.sma(volume, volume_length)
vol_mult = volume / vol_ma
volume_condition = not use_volume_filter or (vol_mult >= volume_mult_min and vol_mult <= volume_mult_max)

// High/Low Filter
highest_price = ta.highest(high, hl_period)
lowest_price = ta.lowest(low, hl_period)
price_change = (close - lowest_price) / lowest_price * 100
hl_condition = not use_hl_filter or price_change >= hl_min_change

// ATR Growth Filter
atr_current = ta.atr(14)
atr_past = ta.sma(atr_current, atr_growth_length)
atr_growth = (atr_current - atr_past) / atr_past * 100
atr_growth_condition = not use_atr_growth or atr_growth >= atr_growth_min

// Prevent multiple orders on same bar
var int lastEntryBar = 0
canEnter = bar_index != lastEntryBar

// Grid variables
var float gridBasePrice = na
var int gridOrderCount = 0
var float[] gridEntryPrices = array.new_float(0)
var float[] gridOrderSizes = array.new_float(0)

// Calculate actual stop loss percent
actual_sl_percent = sl_equals_tp ? take_profit_percent : stop_loss_percent

// SuperTrend Calculations
f_supertrend(src, length, mult) =>
    atr = ta.atr(length)
    up = src - mult * atr
    up1 = nz(up[1], up)
    up := close[1] > up1 ? math.max(up, up1) : up
    dn = src + mult * atr
    dn1 = nz(dn[1], dn)
    dn := close[1] < dn1 ? math.min(dn, dn1) : dn
    trend = 1
    trend := nz(trend[1], trend)
    trend := trend == -1 and close > dn1 ? 1 : trend == 1 and close < up1 ? -1 : trend
    [up, dn, trend]

// SuperTrend 1
[st1_up, st1_dn, st1_trend] = f_supertrend(close, supertrend1_length, supertrend1_mult)
st1_trend_tf = f_security(syminfo.tickerid, supertrend1_tf, st1_trend, false)

// SuperTrend 2
[st2_up, st2_dn, st2_trend] = f_supertrend(close, supertrend2_length, supertrend2_mult)
st2_trend_tf = f_security(syminfo.tickerid, supertrend2_tf, st2_trend, false)

// SuperTrend 3
[st3_up, st3_dn, st3_trend] = f_supertrend(close, supertrend3_length, supertrend3_mult)
st3_trend_tf = f_security(syminfo.tickerid, supertrend3_tf, st3_trend, false)

// MA Calculations
f_ma(source, length, type) =>
    switch type
        "SMA" => ta.sma(source, length)
        "EMA" => ta.ema(source, length)
        "WMA" => ta.wma(source, length)
        "HMA" => ta.hma(source, length)
        "RMA" => ta.rma(source, length)
        "VWMA" => ta.vwma(source, length)
        => ta.sma(source, length)

ma1 = f_ma(close, ma1_length, ma1_type)
ma2 = f_ma(close, ma2_length, ma2_type)

// Channel Calculations
// Bollinger Bands
bb_basis = ta.sma(close, bb_length)
bb_dev_calc = bb_dev * ta.stdev(close, bb_length)
bb_upper = bb_basis + bb_dev_calc
bb_lower = bb_basis - bb_dev_calc

// Keltner Channels
kc_basis = ta.ema(close, keltner_length)
kc_range = ta.atr(keltner_length) * keltner_mult
kc_upper = kc_basis + kc_range
kc_lower = kc_basis - kc_range

// Select channel based on settings
channel_upper = channel_type == "Bollinger" ? bb_upper : kc_upper
channel_lower = channel_type == "Bollinger" ? bb_lower : kc_lower
channel_basis = channel_type == "Bollinger" ? bb_basis : kc_basis

// RSI Calculations
rsi1_value = ta.rsi(close, rsi1_length)
rsi1_mtf = f_security(syminfo.tickerid, rsi1_tf, rsi1_value, false)

rsi2_value = ta.rsi(close, rsi2_length)
rsi2_mtf = f_security(syminfo.tickerid, rsi2_tf, rsi2_value, false)

rsi3_value = ta.rsi(close, rsi3_length)
rsi3_mtf = f_security(syminfo.tickerid, rsi3_tf, rsi3_value, false)

// RVI Calculation
f_rvi(length) =>
    co = close - open
    hl = high - low
    num = ta.ema(co, length)
    den = ta.ema(hl, length)
    rvi = den != 0 ? num / den : 0
    sig = ta.ema(rvi, length)
    [rvi, sig]

[rvi_value, rvi_signal] = f_rvi(rvi_length)

// MFI Calculation
mfi_value = ta.mfi(hlc3, mfi_length)

// CCI Calculation
cci_value = ta.cci(close, cci_length)

// Stochastic Calculation
stoch_k = ta.stoch(close, high, low, stoch_k_length)
stoch_d = ta.sma(stoch_k, stoch_d_length)
stoch_k_smooth = ta.sma(stoch_k, stoch_smooth)

// Momentum Calculation
mom_value = ta.mom(close, mom_length)

// Dynamic RSI Calculation
f_dynamic_rsi(src, length) =>
    avg_gain = ta.rma(math.max(src - src[1], 0), length)
    avg_loss = ta.rma(math.max(src[1] - src, 0), length)
    rs = avg_gain / avg_loss
    drsi = 100 - (100 / (1 + rs))
    drsi

drsi_value = f_dynamic_rsi(close, drsi_length)

// Dynamic MFI Calculation
f_dynamic_mfi(length) =>
    typical_price = hlc3
    raw_money_flow = typical_price * volume
    positive_flow = typical_price > typical_price[1] ? raw_money_flow : 0
    negative_flow = typical_price < typical_price[1] ? raw_money_flow : 0
    positive_mf = ta.rma(positive_flow, length)
    negative_mf = ta.rma(negative_flow, length)
    mf_ratio = positive_mf / negative_mf
    dmfi = 100 - (100 / (1 + mf_ratio))
    dmfi

dmfi_value = f_dynamic_mfi(dmfi_length)

// SMI Ergodic Oscillator
f_smi(short_length, long_length, signal_length) =>
    ll = ta.lowest(low, long_length)
    hh = ta.highest(high, long_length)
    diff = hh - ll
    rdiff = close - (hh + ll) / 2
    avgrel = ta.ema(ta.ema(rdiff, short_length), short_length)
    avgdiff = ta.ema(ta.ema(diff, short_length), short_length)
    smi = avgdiff != 0 ? avgrel / (avgdiff / 2) * 100 : 0
    signal = ta.ema(smi, signal_length)
    [smi, signal]

[smi_value, smi_signal] = f_smi(smi_short_length, smi_long_length, smi_signal_length)

// DMI Calculation
[diplus, diminus, adx] = ta.dmi(dmi_length, dmi_adx_smooth)

// Chaikin Money Flow
f_cmf(length) =>
    ad = close == high and close == low or high == low ? 0 : ((2 * close - low - high) / (high - low)) * volume
    sum_ad = math.sum(ad, length)
    sum_volume = math.sum(volume, length)
    cmf = sum_volume == 0 ? 0 : sum_ad / sum_volume
    cmf

cmf_value = f_cmf(cmf_length)

// Balance of Power
bop_value = (close - open) / (high - low)
bop_smooth = ta.sma(bop_value, bop_length)

// MACD Calculation
[macd_line, macd_signal, macd_hist] = ta.macd(close, macd_fast_length, macd_slow_length, macd_signal_length)

// Parabolic SAR
sar_value = ta.sar(sar_start, sar_increment, sar_max)

// QQE Calculation
f_qqe(src, length, sf, wilders_length) =>
    rsi_src = ta.rsi(src, length)
    rsi_ma = ta.ema(rsi_src, sf)
    atr_rsi = math.abs(rsi_ma[1] - rsi_ma)
    ma_atr_rsi = ta.ema(atr_rsi, wilders_length)
    dar = ta.ema(ma_atr_rsi, wilders_length) * qqe_wilders_length
    
    longband = 0.0
    shortband = 0.0
    trend = 0
    
    DeltaFastAtrRsi = dar
    RSIndex = rsi_ma
    newshortband = RSIndex + DeltaFastAtrRsi
    newlongband = RSIndex - DeltaFastAtrRsi
    
    longband := RSIndex[1] > longband[1] and RSIndex > longband[1] ? math.max(longband[1], newlongband) : newlongband
    shortband := RSIndex[1] < shortband[1] and RSIndex < shortband[1] ? math.min(shortband[1], newshortband) : newshortband
    
    cross_up = ta.crossover(RSIndex, shortband[1])
    cross_down = ta.crossunder(RSIndex, longband[1])
    trend := cross_up ? 1 : cross_down ? -1 : nz(trend[1])
    
    [RSIndex, trend]

[qqe_line, qqe_trend] = f_qqe(close, qqe_rsi_length, qqe_sf, qqe_wilders_length)

// Linear Regression Channel
f_linreg_channel(src, length, deviation) =>
    lr = ta.linreg(src, length, 0)
    lr_slope = (lr - lr[1])
    
    sum_squared_deviations = 0.0
    for i = 0 to length - 1
        sum_squared_deviations += math.pow(src[i] - (lr - lr_slope * i), 2)
    
    std_dev = math.sqrt(sum_squared_deviations / length)
    upper_channel = lr + deviation * std_dev
    lower_channel = lr - deviation * std_dev
    
    [lr, upper_channel, lower_channel]

[lrc_mid, lrc_upper, lrc_lower] = f_linreg_channel(close, lrc_length, lrc_deviation)

// Candlestick Pattern Detection
f_is_hammer() =>
    body = math.abs(close - open)
    lower_shadow = open > close ? close - low : open - low
    upper_shadow = open > close ? high - open : high - close
    lower_shadow > body * 2 and upper_shadow < body * 0.5

f_is_engulfing() =>
    bullish_engulfing = close > open and close[1] < open[1] and open <= close[1] and close >= open[1]
    bearish_engulfing = close < open and close[1] > open[1] and open >= close[1] and close <= open[1]
    [bullish_engulfing, bearish_engulfing]

f_is_doji() =>
    body = math.abs(close - open)
    candle_range = high - low
    body < candle_range * 0.1

[bullish_engulfing, bearish_engulfing] = f_is_engulfing()

// ======== INDICATOR CONDITIONS ========

// SuperTrend Conditions
st1_long = not use_supertrend1 or st1_trend_tf == 1
st1_short = not use_supertrend1 or st1_trend_tf == -1
st2_long = not use_supertrend2 or st2_trend_tf == 1
st2_short = not use_supertrend2 or st2_trend_tf == -1
st3_long = not use_supertrend3 or st3_trend_tf == 1
st3_short = not use_supertrend3 or st3_trend_tf == -1

st_trend_change_long = use_st_trend_change and ta.crossover(st1_trend, 0)
st_trend_change_short = use_st_trend_change and ta.crossunder(st1_trend, 0)

// MA Conditions
ma_cross_long = use_ma and ma_mode == "Cross" and ta.crossover(ma1, ma2)
ma_cross_short = use_ma and ma_mode == "Cross" and ta.crossunder(ma1, ma2)
ma_direction_long = not use_ma or ma_mode != "Direction" or (ma1 > ma1[1] and ma2 > ma2[1])
ma_direction_short = not use_ma or ma_mode != "Direction" or (ma1 < ma1[1] and ma2 < ma2[1])
ma_trend_long = not use_ma or ma_mode != "Trend" or (close > ma1 and close > ma2)
ma_trend_short = not use_ma or ma_mode != "Trend" or (close < ma1 and close < ma2)

// Channel Conditions
var channel_condition_long = false
var channel_condition_short = false

if use_channel
    if channel_mode == "Rebound"
        if channel_entry == "Wick outside"
            channel_condition_long := low <= channel_lower and close > channel_lower
            channel_condition_short := high >= channel_upper and close < channel_upper
        else // Close outside, return and close inside
            channel_condition_long := close[2] < channel_lower[2] and close[1] > channel_lower[1] and close > channel_lower and close < channel_upper
            channel_condition_short := close[2] > channel_upper[2] and close[1] < channel_upper[1] and close < channel_upper and close > channel_lower
    else // Breakout
        channel_condition_long := ta.crossover(close, channel_upper)
        channel_condition_short := ta.crossunder(close, channel_lower)

else
    channel_condition_long := true
    channel_condition_short := true

// RSI Conditions
rsi1_long_cond = not use_rsi1 or not use_rsi1_long or (rsi1_mtf > rsi1_long_above and rsi1_mtf < rsi1_long_below)
rsi1_short_cond = not use_rsi1 or not use_rsi1_short or (rsi1_mtf < rsi1_short_below and rsi1_mtf > rsi1_short_above)
rsi1_cross_long = use_rsi1 and use_rsi1_cross and ta.crossover(rsi1_mtf, rsi1_long_above)
rsi1_cross_short = use_rsi1 and use_rsi1_cross and ta.crossunder(rsi1_mtf, rsi1_short_below)

rsi2_long_cond = not use_rsi2 or not use_rsi2_long or (rsi2_mtf > rsi2_long_above and rsi2_mtf < rsi2_long_below)
rsi2_short_cond = not use_rsi2 or not use_rsi2_short or (rsi2_mtf < rsi2_short_below and rsi2_mtf > rsi2_short_above)

rsi3_long_cond = not use_rsi3 or not use_rsi3_long or (rsi3_mtf > rsi3_long_above and rsi3_mtf < rsi3_long_below)
rsi3_short_cond = not use_rsi3 or not use_rsi3_short or (rsi3_mtf < rsi3_short_below and rsi3_mtf > rsi3_short_above)

// RVI Conditions
rvi_long_cond = not use_rvi or (rvi_value > rvi_long_above and rvi_value < rvi_long_below)
rvi_short_cond = not use_rvi or (rvi_value < rvi_short_below and rvi_value > rvi_short_above)

// MFI Conditions
mfi_long_cond = not use_mfi or (mfi_value > mfi_long_above and mfi_value < mfi_long_below)
mfi_short_cond = not use_mfi or (mfi_value < mfi_short_below and mfi_value > mfi_short_above)

// CCI Conditions
cci_long_cond = not use_cci or (cci_value > cci_long_above and cci_value < cci_long_below)
cci_short_cond = not use_cci or (cci_value < cci_short_below and cci_value > cci_short_above)

// Stochastic Conditions
stoch_long_cond = not use_stoch or (stoch_k_smooth > stoch_long_above and stoch_k_smooth < stoch_long_below)
stoch_short_cond = not use_stoch or (stoch_k_smooth < stoch_short_below and stoch_k_smooth > stoch_short_above)
stoch_cross_long = use_stoch and use_stoch_cross and ta.crossover(stoch_k_smooth, stoch_d)
stoch_cross_short = use_stoch and use_stoch_cross and ta.crossunder(stoch_k_smooth, stoch_d)

// Momentum Conditions
mom_long_cond = not use_mom or (mom_value > mom_long_above and mom_value < mom_long_below)
mom_short_cond = not use_mom or (mom_value < mom_short_below and mom_value > mom_short_above)

// Dynamic RSI Conditions
drsi_long_cond = not use_drsi or (drsi_value > drsi_long_above and drsi_value < drsi_long_below)
drsi_short_cond = not use_drsi or (drsi_value < drsi_short_below and drsi_value > drsi_short_above)

// Dynamic MFI Conditions
dmfi_long_cond = not use_dmfi or (dmfi_value > dmfi_long_above and dmfi_value < dmfi_long_below)
dmfi_short_cond = not use_dmfi or (dmfi_value < dmfi_short_below and dmfi_value > dmfi_short_above)

// SMI Conditions
smi_long_cond = not use_smi or (smi_value > smi_long_above and smi_value < smi_long_below)
smi_short_cond = not use_smi or (smi_value < smi_short_below and smi_value > smi_short_above)

// DMI Conditions
dmi_condition = true
if use_dmi
    if use_dmi_filter == "ADX"
        dmi_condition := adx > dmi_threshold
    else if use_dmi_filter == "DI+"
        dmi_condition := diplus > dmi_threshold
    else if use_dmi_filter == "DI-"
        dmi_condition := diminus > dmi_threshold

// CMF Conditions
cmf_long_cond = not use_cmf or (cmf_value > cmf_long_above and cmf_value < cmf_long_below)
cmf_short_cond = not use_cmf or (cmf_value < cmf_short_below and cmf_value > cmf_short_above)
cmf_cross_long = use_cmf and use_cmf_cross and ta.crossover(cmf_value, 0)
cmf_cross_short = use_cmf and use_cmf_cross and ta.crossunder(cmf_value, 0)

// BOP Conditions
bop_long_cond = not use_bop or (bop_smooth > bop_long_above and bop_smooth < bop_long_below)
bop_short_cond = not use_bop or (bop_smooth < bop_short_below and bop_smooth > bop_short_above)
bop_cross_long = use_bop and use_bop_cross and ta.crossover(bop_smooth, 0)
bop_cross_short = use_bop and use_bop_cross and ta.crossunder(bop_smooth, 0)

// MACD Conditions
macd_long_signal = false
macd_short_signal = false
if use_macd
    if macd_signal_type == "Zero Cross"
        macd_long_signal := ta.crossover(macd_line, 0)
        macd_short_signal := ta.crossunder(macd_line, 0)
    else // Signal Cross
        macd_long_signal := ta.crossover(macd_line, macd_signal)
        macd_short_signal := ta.crossunder(macd_line, macd_signal)

// QQE Conditions
qqe_long_signal = use_qqe and qqe_trend == 1 and qqe_trend[1] != 1
qqe_short_signal = use_qqe and qqe_trend == -1 and qqe_trend[1] != -1

// LRC Conditions
lrc_long_signal = use_lrc and ta.crossover(close, lrc_upper)
lrc_short_signal = use_lrc and ta.crossunder(close, lrc_lower)

// Pattern Conditions
pattern_long_signal = false
pattern_short_signal = false
if use_patterns
    hammer = use_hammer and f_is_hammer()
    pattern_long_signal := hammer or (use_engulfing and bullish_engulfing) or 
                          (use_doji and f_is_doji() and close > close[1])
    pattern_short_signal := (use_engulfing and bearish_engulfing) or 
                           (use_doji and f_is_doji() and close < close[1])

// External Indicator Conditions
ext_long_cond = not use_external or ext_long_condition > ext_long_threshold
ext_short_cond = not use_external or ext_short_condition < ext_short_threshold

// Consolidation Zone
consolidation = false
if use_consolidation
    highest = ta.highest(high, consol_length)
    lowest = ta.lowest(low, consol_length)
    range_pct = (highest - lowest) / lowest * 100
    consolidation := range_pct <= consol_range

// Block if Worse Than
worse_filter_long = true
worse_filter_short = true
if use_worse_filter
    price_move_long = (close - close[1]) / close[1] * 100
    price_move_short = (close[1] - close) / close[1] * 100
    worse_filter_long := price_move_long < worse_percent
    worse_filter_short := price_move_short < worse_percent

// ======== COMBINE ALL CONDITIONS ========

// Long Entry Conditions
long_filters = st1_long and st2_long and st3_long and
               ma_direction_long and ma_trend_long and
               channel_condition_long and
               rsi1_long_cond and rsi2_long_cond and rsi3_long_cond and
               rvi_long_cond and mfi_long_cond and cci_long_cond and
               stoch_long_cond and mom_long_cond and
               drsi_long_cond and dmfi_long_cond and smi_long_cond and
               dmi_condition and cmf_long_cond and bop_long_cond and
               vol_condition and volume_condition and hl_condition and
               atr_growth_condition and worse_filter_long and
               not consolidation and ext_long_cond

long_signals = ma_cross_long or st_trend_change_long or rsi1_cross_long or
               stoch_cross_long or cmf_cross_long or bop_cross_long or
               macd_long_signal or qqe_long_signal or lrc_long_signal or
               pattern_long_signal

// Short Entry Conditions
short_filters = (
  st1_short
  and st2_short
  and st3_short
  and ma_direction_short
  and ma_trend_short
  and channel_condition_short
  and rsi1_short_cond
  and rsi2_short_cond
  and rsi3_short_cond
  and rvi_short_cond
  and mfi_short_cond
  and cci_short_cond
  and stoch_short_cond
  and mom_short_cond
  and drsi_short_cond
  and dmfi_short_cond
  and smi_short_cond
  and dmi_condition
  and cmf_short_cond
  and bop_short_cond
  and vol_condition
  and volume_condition
  and hl_condition
  and atr_growth_condition
  and worse_filter_short
  and not consolidation
  and ext_short_cond
)



short_signals = ma_cross_short or st_trend_change_short or rsi1_cross_short or
                stoch_cross_short or cmf_cross_short or bop_cross_short or
                macd_short_signal or qqe_short_signal or lrc_short_signal or
                pattern_short_signal

// Final Entry Conditions
longCondition = use_long and long_filters and (long_signals or not (use_ma or use_st_trend_change or 
                use_rsi1 or use_stoch or use_cmf or use_bop or use_macd or use_qqe or use_lrc or use_patterns)) and
                inDateRange and tradingDay and canEnter

shortCondition = use_short and short_filters and (short_signals or not (use_ma or use_st_trend_change or 
                 use_rsi1 or use_stoch or use_cmf or use_bop or use_macd or use_qqe or use_lrc or use_patterns)) and
                 inDateRange and tradingDay and canEnter

// ======== POSITION MANAGEMENT ========

var float entry_price = na
var float tp_price = na
var float sl_price = na
var float be_activated = false
var float trail_activated = false
var float trail_price = na

// Calculate position size for grid
position_size = deposit_size * leverage / num_orders

// Grid Order Calculation
f_calculate_grid_levels(base_price, direction, grid_size, order_count, martingale_mult, log_step) =>
    prices = array.new_float(order_count)
    sizes = array.new_float(order_count)
    
    total_size = 0.0
    for i = 0 to order_count - 1
        size_mult = math.pow(martingale_mult, i)
        total_size += size_mult
    
    normalized_size = 1.0 / total_size
    
    for i = 0 to order_count - 1
        // Calculate price levels
        if i == 0
            array.set(prices, i, base_price)
        else
            step_mult = math.pow(log_step, i)
            price_step = grid_size / 100 * step_mult / order_count
            if direction == "Long"
                array.set(prices, i, base_price * (1 - price_step * i))
            else
                array.set(prices, i, base_price * (1 + price_step * i))
        
        // Calculate order sizes
        size_mult = math.pow(martingale_mult, i)
        array.set(sizes, i, normalized_size * size_mult)
    
    [prices, sizes]

// ======== CLOSE CONDITIONS ========

// RSI Close Conditions
rsi_close_long = false
rsi_close_short = false
if use_rsi_close
    if rsi_close_type == "Level"
        rsi_close_long := rsi1_value >= rsi_close_long_level
        rsi_close_short := rsi1_value <= rsi_close_short_level
    else // Cross
        rsi_close_long := ta.crossover(rsi1_value, rsi_close_long_level)
        rsi_close_short := ta.crossunder(rsi1_value, rsi_close_short_level)

// Stochastic Close Conditions
stoch_close_long = false
stoch_close_short = false
if use_stoch_close
    if stoch_close_type == "Level"
        stoch_close_long := stoch_k_smooth >= stoch_close_long_level
        stoch_close_short := stoch_k_smooth <= stoch_close_short_level
    else // Cross
        stoch_close_long := ta.crossover(stoch_k_smooth, stoch_close_long_level)
        stoch_close_short := ta.crossunder(stoch_k_smooth, stoch_close_short_level)

// SAR Close Conditions
sar_close_long = use_sar_close and close < sar_value
sar_close_short = use_sar_close and close > sar_value

// Channel Close Conditions
channel_close_long = false
channel_close_short = false
if use_channel_close
    close_upper = close_channel_type == "Bollinger" ? bb_upper : kc_upper
    close_lower = close_channel_type == "Bollinger" ? bb_lower : kc_lower
    channel_close_long := high >= close_upper
    channel_close_short := low <= close_lower

// MA Cross Close
ma_close_long = use_ma_close and ta.crossunder(ma1, ma2)
ma_close_short = use_ma_close and ta.crossover(ma1, ma2)

// Combine all close conditions
close_long_condition = rsi_close_long or stoch_close_long or sar_close_long or 
                      channel_close_long or ma_close_long

close_short_condition = rsi_close_short or stoch_close_short or sar_close_short or 
                       channel_close_short or ma_close_short

// ======== ENTRY LOGIC ========

if longCondition and grid_direction == "Long" and strategy.position_size == 0
    lastEntryBar := bar_index
    
    if use_grid
        gridBasePrice := close
        gridOrderCount := 0
        [grid_prices, grid_sizes] = f_calculate_grid_levels(close, "Long", grid_size_percent, num_orders, martingale, log_steps)
        
        // Enter first order
        first_size = array.get(grid_sizes, 0) * deposit_size * leverage
        strategy.entry("Long_0", strategy.long, qty=first_size, alert_message=webhook_message_long)
        gridOrderCount += 1
        
        // Store entry info
        array.push(gridEntryPrices, close)
        array.push(gridOrderSizes, first_size)
    else
        strategy.entry("Long", strategy.long, qty=position_size, alert_message=webhook_message_long)
    
    entry_price := close
    tp_price := close * (1 + take_profit_percent / 100)
    sl_price := close * (1 - actual_sl_percent / 100)
    be_activated := false
    trail_activated := false

if shortCondition and grid_direction == "Short" and strategy.position_size == 0
    lastEntryBar := bar_index
    
    if use_grid
        gridBasePrice := close
        gridOrderCount := 0
        [grid_prices, grid_sizes] = f_calculate_grid_levels(close, "Short", grid_size_percent, num_orders, martingale, log_steps)
        
        // Enter first order
        first_size = array.get(grid_sizes, 0) * deposit_size * leverage
        strategy.entry("Short_0", strategy.short, qty=first_size, alert_message=webhook_message_short)
        gridOrderCount += 1
        
        // Store entry info
        array.push(gridEntryPrices, close)
        array.push(gridOrderSizes, first_size)
    else
        strategy.entry("Short", strategy.short, qty=position_size, alert_message=webhook_message_short)
    
    entry_price := close
    tp_price := close * (1 - take_profit_percent / 100)
    sl_price := close * (1 + actual_sl_percent / 100)
    be_activated := false
    trail_activated := false

// ======== GRID MANAGEMENT ========

if use_grid and strategy.position_size != 0 and gridOrderCount > 0 and gridOrderCount < num_orders
    current_drawdown = strategy.position_size > 0 ? 
                      (close - strategy.position_avg_price) / strategy.position_avg_price * 100 : 
                      (strategy.position_avg_price - close) / strategy.position_avg_price * 100
    
    // Check for next grid level
    [grid_prices, grid_sizes] = f_calculate_grid_levels(gridBasePrice, grid_direction, grid_size_percent, num_orders, martingale, log_steps)
    
    next_price = array.get(grid_prices, gridOrderCount)
    
    // Long grid orders
    if grid_direction == "Long" and strategy.position_size > 0
        if close <= next_price and close >= next_price * 0.99
            next_size = array.get(grid_sizes, gridOrderCount) * deposit_size * leverage
            strategy.entry("Long_" + str.tostring(gridOrderCount), strategy.long, qty=next_size, alert_message=alert_first_only ? na : webhook_message_long)
            gridOrderCount += 1
            array.push(gridEntryPrices, close)
            array.push(gridOrderSizes, next_size)
    
    // Short grid orders
    if grid_direction == "Short" and strategy.position_size < 0
        if close >= next_price and close <= next_price * 1.01
            next_size = array.get(grid_sizes, gridOrderCount) * deposit_size * leverage
            strategy.entry("Short_" + str.tostring(gridOrderCount), strategy.short, qty=next_size, alert_message=alert_first_only ? na : webhook_message_short)
            gridOrderCount += 1
            array.push(gridEntryPrices, close)
                        array.push(gridOrderSizes, next_size)

// ======== MULTI TAKE PROFIT ========

if use_multi_tp and strategy.position_size != 0
    if strategy.position_size > 0
        // Long TPs
        if close >= entry_price * (1 + tp1_percent / 100)
            strategy.close("Long", qty_percent=tp1_qty, comment="TP1", alert_message=webhook_message_close)
        if close >= entry_price * (1 + tp2_percent / 100)
            strategy.close("Long", qty_percent=tp2_qty, comment="TP2", alert_message=webhook_message_close)
        if close >= entry_price * (1 + tp3_percent / 100)
            strategy.close("Long", qty_percent=tp3_qty, comment="TP3", alert_message=webhook_message_close)
        if close >= entry_price * (1 + tp4_percent / 100)
            strategy.close("Long", qty_percent=tp4_qty, comment="TP4", alert_message=webhook_message_close)
    else
        // Short TPs
        if close <= entry_price * (1 - tp1_percent / 100)
            strategy.close("Short", qty_percent=tp1_qty, comment="TP1", alert_message=webhook_message_close)
        if close <= entry_price * (1 - tp2_percent / 100)
            strategy.close("Short", qty_percent=tp2_qty, comment="TP2", alert_message=webhook_message_close)
        if close <= entry_price * (1 - tp3_percent / 100)
            strategy.close("Short", qty_percent=tp3_qty, comment="TP3", alert_message=webhook_message_close)
        if close <= entry_price * (1 - tp4_percent / 100)
            strategy.close("Short", qty_percent=tp4_qty, comment="TP4", alert_message=webhook_message_close)

// ======== BREAKEVEN LOGIC ========

if use_breakeven and strategy.position_size != 0 and not be_activated
    if strategy.position_size > 0
        if close >= entry_price * (1 + be_trigger_percent / 100)
            sl_price := entry_price * (1 + be_offset_percent / 100)
            be_activated := true
    else
        if close <= entry_price * (1 - be_trigger_percent / 100)
            sl_price := entry_price * (1 - be_offset_percent / 100)
            be_activated := true

// ======== TRAILING STOP LOGIC ========

if use_trailing and strategy.position_size != 0
    if strategy.position_size > 0
        if not trail_activated and close >= entry_price * (1 + trail_activate_percent / 100)
            trail_activated := true
            trail_price := close * (1 - trail_distance_percent / 100)
        else if trail_activated
            new_trail_price = close * (1 - trail_distance_percent / 100)
            if new_trail_price > trail_price
                trail_price := new_trail_price
    else
        if not trail_activated and close <= entry_price * (1 - trail_activate_percent / 100)
            trail_activated := true
            trail_price := close * (1 + trail_distance_percent / 100)
        else if trail_activated
            new_trail_price = close * (1 + trail_distance_percent / 100)
            if new_trail_price < trail_price
                trail_price := new_trail_price

// ======== ADJUST TP FOR MANY ORDERS ========

adjusted_tp = take_profit_percent
if change_tp_many and gridOrderCount >= orders_threshold
    adjusted_tp := new_tp_percent

// ======== POSITION CLOSING ========

// Check drawdown limit
if close_on_drawdown and strategy.position_size != 0
    current_pnl = strategy.openprofit
    if current_pnl <= drawdown_limit
        strategy.close_all(comment="Drawdown Limit", alert_message=webhook_message_close)
        gridOrderCount := 0
        array.clear(gridEntryPrices)
        array.clear(gridOrderSizes)

// Close only in profit filter
can_close = not close_profit_only or strategy.openprofit > 0

// Static TP/SL
if strategy.position_size > 0
    if close_on_tp and close >= tp_price
        strategy.close_all(comment="TP", alert_message=webhook_message_close)
        gridOrderCount := 0
        array.clear(gridEntryPrices)
        array.clear(gridOrderSizes)
    if close_on_sl and close <= sl_price
        if reverse_on_sl
            strategy.close_all(comment="SL Reverse", alert_message=webhook_message_close)
            strategy.entry("Short", strategy.short, qty=position_size, alert_message=webhook_message_short)
        else
            strategy.close_all(comment="SL", alert_message=webhook_message_close)
        gridOrderCount := 0
        array.clear(gridEntryPrices)
        array.clear(gridOrderSizes)

if strategy.position_size < 0
    if close_on_tp and close <= tp_price
        strategy.close_all(comment="TP", alert_message=webhook_message_close)
        gridOrderCount := 0
        array.clear(gridEntryPrices)
        array.clear(gridOrderSizes)
    if close_on_sl and close >= sl_price
        if reverse_on_sl
            strategy.close_all(comment="SL Reverse", alert_message=webhook_message_close)
            strategy.entry("Long", strategy.long, qty=position_size, alert_message=webhook_message_long)
        else
            strategy.close_all(comment="SL", alert_message=webhook_message_close)
        gridOrderCount := 0
        array.clear(gridEntryPrices)
        array.clear(gridOrderSizes)

// ATR TP/SL
if strategy.position_size > 0
    if close_on_atr_tp and close >= entry_price + atr_tp
        strategy.close_all(comment="ATR TP", alert_message=webhook_message_close)
        gridOrderCount := 0
        array.clear(gridEntryPrices)
        array.clear(gridOrderSizes)
    if close_on_atr_sl and close <= entry_price - atr_sl
        strategy.close_all(comment="ATR SL", alert_message=webhook_message_close)
        gridOrderCount := 0
        array.clear(gridEntryPrices)
        array.clear(gridOrderSizes)

if strategy.position_size < 0
    if close_on_atr_tp and close <= entry_price - atr_tp
        strategy.close_all(comment="ATR TP", alert_message=webhook_message_close)
        gridOrderCount := 0
        array.clear(gridEntryPrices)
        array.clear(gridOrderSizes)
    if close_on_atr_sl and close >= entry_price + atr_sl
        strategy.close_all(comment="ATR SL", alert_message=webhook_message_close)
        gridOrderCount := 0
        array.clear(gridEntryPrices)
        array.clear(gridOrderSizes)

// Trailing Stop Close
if trail_activated and can_close
    if strategy.position_size > 0 and close <= trail_price
        strategy.close_all(comment="Trail Stop", alert_message=webhook_message_close)
        gridOrderCount := 0
        array.clear(gridEntryPrices)
        array.clear(gridOrderSizes)
    if strategy.position_size < 0 and close >= trail_price
        strategy.close_all(comment="Trail Stop", alert_message=webhook_message_close)
        gridOrderCount := 0
        array.clear(gridEntryPrices)
        array.clear(gridOrderSizes)

// Signal-based closes
if can_close and ((strategy.position_size > 0 and close_long_condition) or 
   (strategy.position_size < 0 and close_short_condition))
    strategy.close_all(comment="Signal Close", alert_message=webhook_message_close)
    gridOrderCount := 0
    array.clear(gridEntryPrices)
    array.clear(gridOrderSizes)

// ======== VISUALIZATION ========

// Plot channels
plot(use_channel and show_tp_sl ? channel_upper : na, "Channel Upper", color=color.blue, linewidth=1)
plot(use_channel and show_tp_sl ? channel_lower : na, "Channel Lower", color=color.blue, linewidth=1)
plot(use_channel and show_tp_sl ? channel_basis : na, "Channel Basis", color=color.gray, linewidth=1, style=plot.style_line)

// Plot MAs
plot(use_ma and show_tp_sl ? ma1 : na, "MA1", color=color.orange, linewidth=2)
plot(use_ma and show_tp_sl ? ma2 : na, "MA2", color=color.purple, linewidth=2)

// Plot TP/SL levels
plot(strategy.position_size != 0 and show_tp_sl ? tp_price : na, "TP", color=color.green, linewidth=2, style=plot.style_line)
plot(strategy.position_size != 0 and show_tp_sl ? sl_price : na, "SL", color=color.red, linewidth=2, style=plot.style_line)
plot(strategy.position_size != 0 and show_tp_sl ? entry_price : na, "Entry", color=color.yellow, linewidth=1, style=plot.style_line)
plot(trail_activated and show_tp_sl ? trail_price : na, "Trail Stop", color=color.orange, linewidth=1, style=plot.style_line)

// Plot grid levels
if use_grid and show_tp_sl and strategy.position_size != 0
    [grid_prices_viz, grid_sizes_viz] = f_calculate_grid_levels(gridBasePrice, grid_direction, grid_size_percent, num_orders, martingale, log_steps)
    for i = 1 to num_orders - 1
        price_level = array.get(grid_prices_viz, i)
        line.new(bar_index - 10, price_level, bar_index + 10, price_level, color=color.gray, style=line.style_dashed, width=1)

// Signal visualization
plotshape(show_signals and longCondition and strategy.position_size == 0, "Long Signal", shape.triangleup, location.belowbar, color.green, size=size.small)
plotshape(show_signals and shortCondition and strategy.position_size == 0, "Short Signal", shape.triangledown, location.abovebar, color.red, size=size.small)

// Close signals
plotshape(show_signals and strategy.position_size > 0 and close_long_condition, "Close Long", shape.xcross, location.abovebar, color.orange, size=size.tiny)
plotshape(show_signals and strategy.position_size < 0 and close_short_condition, "Close Short", shape.xcross, location.belowbar, color.orange, size=size.tiny)

// Plot indicators
bgcolor(use_consolidation and consolidation ? color.new(color.gray, 90) : na, title="Consolidation Zone")

// SuperTrend visualization
plot(use_supertrend1 and st1_trend == 1 ? st1_dn : na, "ST1 Support", color=color.green, linewidth=1)
plot(use_supertrend1 and st1_trend == -1 ? st1_up : na, "ST1 Resistance", color=color.red, linewidth=1)

// ======== INFO TABLE ========

var table infoTable = table.new(position.top_right, 2, 20, bgcolor=color.new(color.black, 80))

if barstate.islast
    table.cell(infoTable, 0, 0, "Grid Direction:", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 0, grid_direction, text_color=color.white, text_size=size.small)
    
    table.cell(infoTable, 0, 1, "Grid Orders:", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 1, str.tostring(gridOrderCount) + "/" + str.tostring(num_orders), text_color=color.white, text_size=size.small)
    
    table.cell(infoTable, 0, 2, "Position Size:", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 2, str.tostring(math.abs(strategy.position_size)), text_color=color.white, text_size=size.small)
    
    table.cell(infoTable, 0, 3, "Avg Price:", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 3, str.tostring(strategy.position_avg_price, "#.####"), text_color=color.white, text_size=size.small)
    
    table.cell(infoTable, 0, 4, "Current P&L:", text_color=color.white, text_size=size.small)
    pnl_color = strategy.openprofit > 0 ? color.green : color.red
    table.cell(infoTable, 1, 4, str.tostring(strategy.openprofit, "#.##") + "$", text_color=pnl_color, text_size=size.small)
    
    table.cell(infoTable, 0, 5, "BE Active:", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 5, str.tostring(be_activated), text_color=color.white, text_size=size.small)
    
    table.cell(infoTable, 0, 6, "Trail Active:", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 6, str.tostring(trail_activated), text_color=color.white, text_size=size.small)

// ======== ALERTS ========

// Entry alerts
if longCondition and strategy.position_size[1] == 0
    alert("Long Entry Signal\nPrice: " + str.tostring(close) + "\nMessage: " + webhook_message_long, alert.freq_once_per_bar)

if shortCondition and strategy.position_size[1] == 0
    alert("Short Entry Signal\nPrice: " + str.tostring(close) + "\nMessage: " + webhook_message_short, alert.freq_once_per_bar)

// Close alerts
if strategy.position_size[1] != 0 and strategy.position_size == 0
    alert("Position Closed\nPrice: " + str.tostring(close) + "\nMessage: " + webhook_message_close, alert.freq_once_per_bar)

// Grid alerts
if use_grid and gridOrderCount > gridOrderCount[1]
    alert("Grid Order Added #" + str.tostring(gridOrderCount) + "\nPrice: " + str.tostring(close), alert.freq_once_per_bar)

// Drawdown alert
if close_on_drawdown and strategy.openprofit <= drawdown_limit * 0.8
    alert("Warning: Approaching Drawdown Limit\nCurrent P&L: " + str.tostring(strategy.openprofit), alert.freq_once_per_bar)

// ======== PERFORMANCE METRICS ========

var float totalTrades = 0
var float winningTrades = 0
var float totalProfit = 0
var float maxDrawdown = 0
var float currentDrawdown = 0

if strategy.closedtrades > totalTrades
    totalTrades := strategy.closedtrades
    if strategy.closedtrades.profit(strategy.closedtrades - 1) > 0
        winningTrades += 1
    totalProfit += strategy.closedtrades.profit(strategy.closedtrades - 1)

if strategy.position_size != 0
    currentDrawdown := math.min(strategy.openprofit, currentDrawdown)
    maxDrawdown := math.min(maxDrawdown, currentDrawdown)
else
    currentDrawdown := 0

winRate = totalTrades > 0 ? winningTrades / totalTrades * 100 : 0

// Performance table
var table perfTable = table.new(position.bottom_right, 2, 5, bgcolor=color.new(color.black, 80))

if barstate.islast
    table.cell(perfTable, 0, 0, "Total Trades:", text_color=color.white, text_size=size.small)
    table.cell(perfTable, 1, 0, str.tostring(totalTrades), text_color=color.white, text_size=size.small)
    
    table.cell(perfTable, 0, 1, "Win Rate:", text_color=color.white, text_size=size.small)
    table.cell(perfTable, 1, 1, str.tostring(winRate, "#.#") + "%", text_color=color.white, text_size=size.small)
    
    table.cell(perfTable, 0, 2, "Total Profit:", text_color=color.white, text_size=size.small)
    profit_color = totalProfit > 0 ? color.green : color.red
    table.cell(perfTable, 1, 2, str.tostring(totalProfit, "#.##") + "$", text_color=profit_color, text_size=size.small)
    
    table.cell(perfTable, 0, 3, "Max Drawdown:", text_color=color.white, text_size=size.small)
    table.cell(perfTable, 1, 3, str.tostring(maxDrawdown, "#.##") + "$", text_color=color.red, text_size=size.small)

// ======== END OF STRATEGY ========
